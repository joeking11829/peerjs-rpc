import sha1
import bluebird as Promise
import peerjs as Peer

export RPC


class RPC
  _callbacks: {}

  init: (id, scope, peerOptions, peerConfig) ->
    @peer = new Peer(id, peerOptions, peerConfig)
    @scope = scope
    @id = id

    @peer.on('connection', (connection) ->
      connection.on('data', (data) -> @@@_onData(connection, data))
    )

  invoke: (id, func, args, callback) ->
    signature = @_createSignature()
    return @_getConnection(id)
      .then((connection) ->
        return new Promise((resolve) ->
          @@@_callbacks[signature] = resolve

          connection.send({
            type: 'rpc-invoke'
            func: func
            args: args
            orig: @@@id
            signature: signature
          })
        )
      ).nodeify(callback)

  attr: (id, attr, callback) ->
    signature = @_createSignature()
    return @_getConnection(id)
      .then((connection) ->
        return new Promise((resolve) ->
          @@@_callbacks[signature] = resolve
          connection.send({
            type: 'rpc-attr'
            attr: attr
            orig: @@id
            signature: signature
          })
        )
      ).nodeify(callback)

  ping: (id, callback) ->
    signature = @_createSignature()
    return @_getConnection(id)
      .then((connection) ->
        return new Promise((resolve) ->
          @@@_callbacks[signature] = resolve
          connection.send({
            type: 'rpc-ping',
            orig: @@@id,
            signature: signature
          })
        )
    ).nodeify(callback)

  _createSignature: () -> sha1(Date.now())

  _onData: (connection, data) ->
    if not 'type' in data
      return

    if data.type.match(/^rpc-(:?ping|attr|invoke)$/)
      @_handlers[data.type].bind(@)(connection, data)

    else if data.type.match(/return/)
      @_callbacks[data.signature](data.data)

    else if data.type.match(/pong/)
      @_callbacks[data.signature](true)

  _getConnection: (id, callback) ->
    return new Promise((resolve) ->
      connection = @@peer.connect(id)
      if connection
        connection.on('data', (data) -> @@@_onData(connection, data))
        if connection.open
          resolve(connection)
        else
          connection.on('open', (conn) ->
            resolve(connection)
          )
    ).nodeify(callback)

  _handlers: {
    'rpc-ping': (connection, data) ->
      connection.send({
        type: 'rpc-pong'
        signature: data.signature
        orig: @id
      })

    'rpc-attr': (connection, data) ->
      connection.send({
        type: 'rpc-attr-return'
        data: @scope[data.attr]
        signature: data.signature
        orig: @id
      })

    'rpc-invoke': (connection, data) ->
      if data.func in @scope
        if data.args == undefined then data.args = []
        if not Array.isArray(data.args) then data.args = [data.args]
        data.args.push((err, result) ->
          connection.send({
            type: 'rpc-return'
            data: result
            signature: data.signature
            orig: @id
          })
        )
        @scope[data.func].apply(@scope, data.args)
      else
        connection.send({
            type: 'rpc-return'
            data: new Error('unknown function')
            signature: data.signature
            orig: @id
        })
    }
