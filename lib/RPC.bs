import sha1
import bluebird as Promise
import peerjs as Peer

export RPC


class RPC
  _callbacks: {}

  init: (id, scope, options) ->
    if options
      peerOptions = options.peerOptions or {}
      peerConfig = options.peerConfig or {}
      @debug = options.debug
    @peer = new Peer(id, peerOptions, peerConfig)
    @scope = scope
    @id = id

    @peer.on('connection', (connection) ->
      connection.on('data', (data) -> @@@_onData(connection, data))
    )

  invoke: (id, func, args, callback) ->
    payload = {
      type: 'rpc-invoke'
      func: func
      args: args
      orig: @id
      signature: @_createSignature()
    }
    return @_send(id, payload).nodeify(callback)

  attr: (id, attr, callback) ->
    payload = {
      type: 'rpc-attr'
      attr: attr
      orig: @id
      signature: @_createSignature()
    }
    return @_send(id, payload).nodeify(callback)

  ping: (id, callback) ->
    payload = {
      type: 'rpc-ping',
      orig: @id,
      signature: @_createSignature()
    }
    return @_send(id, payload).nodeify(callback)

  _createSignature: () -> sha1(Date.now())

  _onData: (connection, data) ->
    if not 'type' in data
      return

    if data.type.match(/^rpc-(:?ping|attr|invoke)$/)
      @_handlers[data.type].bind(@)(connection, data)

    else if data.type.match(/return/)
      @_callbacks[data.signature](data.data)

    else if data.type.match(/pong/)
      @_callbacks[data.signature](true)

  _getConnection: (id) ->
    return new Promise((resolve) ->
      connection = @@peer.connect(id)
      if connection
        connection.on('data', (data) -> @@@_onData(connection, data))
        if connection.open
          resolve(connection)
        else
          connection.on('open', (conn) ->
            resolve(connection)
          )
    )

  _send: (id, payload) ->
    return @_getConnection(id)
      .then((connection) ->
        return new Promise((resolve) ->
          @@@_callbacks[payload.signature] = resolve
          connection.send(payload)
        )
      )

  _log: (message) ->
    if not debug then return
    try
      console.log('RPC:  #{JSON.stringify(message)}')
    catch e
      console.log('RPC:  #{message}')

  _handlers: {
    'rpc-ping': (connection, data) ->
      connection.send({
        type: 'rpc-pong'
        signature: data.signature
        orig: @id
      })

    'rpc-attr': (connection, data) ->
      connection.send({
        type: 'rpc-attr-return'
        data: @scope[data.attr]
        signature: data.signature
        orig: @id
      })

    'rpc-invoke': (connection, data) ->
      if data.func in @scope
        if data.args == undefined then data.args = []
        if not Array.isArray(data.args) then data.args = [data.args]
        data.args.push((err, result) ->
          connection.send({
            type: 'rpc-return'
            data: result
            signature: data.signature
            orig: @id
          })
        )
        @scope[data.func].apply(@scope, data.args)
      else
        connection.send({
            type: 'rpc-return'
            data: new Error('unknown function')
            signature: data.signature
            orig: @id
        })
    }
